Item 1-Quantos pipes serão criados após as linhas de código a seguir? Por quê?


(a)
	int pid;
	int fd[2];
	pipe(fd);
	pid = fork();

É criado um pipe.Porque defini o tamanho do array fd[2] de tamanho 2.

(b)

	int pid;
	int fd[2];
	pid = fork();
	pipe(fd);

Nenhum porque o pipe foi executado depois da criação do processo.

Item 2 Apresente mais cinco sinais importantes do ambiente Unix, além do SIGSEGV, SIGUSR1, SIGUSR2, 
SIGALRM e SIGINT. 
Quais são suas características e utilidades? 
Respostas:

1-SIGKILL(Destruição):Para matar os processos. Não pode ser ignorada, nem interceptada. Existe ainda o 
SIGTERM para uma morte mais “suave” do processos. 

2- SIGCLD - Matar o processo filho:
 Enviado ao pai pela terminaçãp de um processo filho. 

3- SIGSYS: Argumento incorreto de uma chamada de sistema 

4- SIGIOT: Problemas de instrução de entrada/saída, emitido quando da erro material dependente da 
implementação. 

5- SIGEMT: Problemas de instrução no emulador: emitido em caso de erro material depedente da 
implementação.

Item 3 Considere o código a seguir:

#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void tratamento_alarme(int sig)
{
	system("date");
	alarm(1);
}

int main()
{
	signal(SIGALRM, tratamento_alarme);
	alarm(1);
	printf("Aperte CTRL+C para acabar:\n");
	while(1);
	return 0;
}

Sabendo que a função alarm() tem como entrada a quantidade de segundos para terminar a contagem,
quão precisos são os alarmes criados neste código? 
De onde vem a imprecisão? Este é um método confiável para desenvolver aplicações em tempo real?

Resposta : Muito preciso em 1 segundo. A precisão vem do relógio que está no processo date, se for
em 1 segundo, pode se que sim.


